================================================================================
BEGIN FILE: dump_repo.py
================================================================================
#!/usr/bin/env python3
"""
Dump selected source files from a repo into one or more text files, with clear file headers.

- Includes: .py, .html, .htm, .css, .js  (optionally .ts/.tsx via --include-ts)
- Skips: virtualenvs, .git, node_modules, caches, build artifacts, etc.
- Avoids minified assets (*.min.js, *.min.css) by default.
- Handles weird encodings gracefully.
- Can split output into multiple chunks by size.

Usage:
  python dump_repo.py --root . --out repo_dump.txt
  python dump_repo.py --root /path/to/repo --out dump.txt --max-chunk-mb 20 --include-ts
"""

from __future__ import annotations
import argparse
import os
import sys
from pathlib import Path

DEFAULT_EXTS = {".py", ".pyw", ".html", ".htm", ".css", ".js"}
TS_EXTS = {".ts", ".tsx"}
# Directories to always skip (case-sensitive directory names)
SKIP_DIRS = {
    ".git", ".hg", ".svn",
    ".venv", "venv", "env",
    "__pycache__", ".mypy_cache", ".pytest_cache", ".ruff_cache", ".cache",
    "node_modules", "bower_components",
    "dist", "build", ".next", "out", "coverage", "site-packages", ".tox",
    ".idea", ".vscode"
}
# File name patterns (suffix-based) to skip
SKIP_SUFFIXES = {
    ".min.js", ".min.css",
}
# Extra large single-file cap (bytes). 0 = no per-file cap.
DEFAULT_PER_FILE_MAX = 0

HEADER_LINE = "=" * 80

def should_skip_dir(dirname: str) -> bool:
    return dirname in SKIP_DIRS

def should_include_file(path: Path, allowed_exts: set[str], skip_suffixes: set[str]) -> bool:
    name = path.name
    # Skip obvious binary or minified variants by suffix
    for suf in skip_suffixes:
        if name.endswith(suf):
            return False
    return path.suffix.lower() in allowed_exts

def write_section(writer, rel_path: str, text: str):
    writer.write(f"{HEADER_LINE}\n")
    writer.write(f"BEGIN FILE: {rel_path}\n")
    writer.write(f"{HEADER_LINE}\n")
    writer.write(text)
    if text and not text.endswith("\n"):
        writer.write("\n")
    writer.write(f"{HEADER_LINE}\n")
    writer.write(f"END FILE: {rel_path}\n")
    writer.write(f"{HEADER_LINE}\n\n")

def iter_files(root: Path, allowed_exts: set[str], skip_suffixes: set[str]):
    for dirpath, dirnames, filenames in os.walk(root):
        # prune directories in-place
        dirnames[:] = [d for d in dirnames if not should_skip_dir(d)]
        for fname in filenames:
            p = Path(dirpath) / fname
            if should_include_file(p, allowed_exts, skip_suffixes):
                yield p

def read_text_best_effort(p: Path, per_file_max: int) -> str:
    # Try UTF-8 first, then fall back to latin-1 as a last resort, replacing errors.
    size = p.stat().st_size
    if per_file_max > 0 and size > per_file_max:
        # Read only the head/tail around per_file_max bytes, with a notice
        head_bytes = per_file_max // 2
        tail_bytes = per_file_max - head_bytes
        try:
            with p.open("rb") as f:
                head = f.read(head_bytes)
                if size > head_bytes:
                    f.seek(max(0, size - tail_bytes))
                    tail = f.read(tail_bytes)
                else:
                    tail = b""
            head_txt = head.decode("utf-8", errors="replace")
            tail_txt = tail.decode("utf-8", errors="replace")
        except Exception:
            # last resort
            head_txt = head.decode("latin-1", errors="replace")
            tail_txt = tail.decode("latin-1", errors="replace")

        notice = (
            f"\n\n<<< NOTE: file truncated for size ({size} bytes); "
            f"showing first {head_bytes} bytes and last {tail_bytes} bytes >>>\n\n"
        )
        return head_txt + notice + tail_txt

    # Normal full read
    try:
        return p.read_text(encoding="utf-8", errors="replace")
    except Exception:
        return p.read_text(encoding="latin-1", errors="replace")

def ensure_parent(path: Path):
    path.parent.mkdir(parents=True, exist_ok=True)

def next_chunk_path(base: Path, idx: int) -> Path:
    if idx == 1:
        return base
    stem = base.stem
    return base.with_name(f"{stem}.part{idx}{base.suffix}")

def dump_repo(
    root: Path,
    out_path: Path,
    allowed_exts: set[str],
    skip_suffixes: set[str],
    per_file_max: int,
    max_chunk_mb: int,
):
    files = sorted(iter_files(root, allowed_exts, skip_suffixes))
    if not files:
        print("No matching files found.", file=sys.stderr)
        return

    max_chunk_bytes = max_chunk_mb * 1024 * 1024 if max_chunk_mb > 0 else 0
    chunk_idx = 1
    current_out = next_chunk_path(out_path, chunk_idx)
    ensure_parent(current_out)
    writer = current_out.open("w", encoding="utf-8", newline="\n")
    written_bytes = 0

    def rotate_writer():
        nonlocal writer, written_bytes, chunk_idx, current_out
        if writer:
            writer.close()
        chunk_idx += 1
        current_out = next_chunk_path(out_path, chunk_idx)
        ensure_parent(current_out)
        writer = current_out.open("w", encoding="utf-8", newline="\n")
        written_bytes = 0

    root = root.resolve()
    for p in files:
        rel_path = str(p.resolve().relative_to(root))
        text = read_text_best_effort(p, per_file_max)
        section = []
        section.append(f"{HEADER_LINE}\n")
        section.append(f"BEGIN FILE: {rel_path}\n")
        section.append(f"{HEADER_LINE}\n")
        section.append(text)
        if text and not text.endswith("\n"):
            section.append("\n")
        section.append(f"{HEADER_LINE}\n")
        section.append(f"END FILE: {rel_path}\n")
        section.append(f"{HEADER_LINE}\n\n")
        blob = "".join(section)
        blob_bytes = len(blob.encode("utf-8", errors="replace"))

        if max_chunk_bytes and written_bytes + blob_bytes > max_chunk_bytes and written_bytes > 0:
            rotate_writer()

        writer.write(blob)
        written_bytes += blob_bytes

    writer.close()
    print(f"Done. Wrote {chunk_idx} file(s) starting at: {out_path}")

def main():
    ap = argparse.ArgumentParser(description="Dump repo source files into a text bundle.")
    ap.add_argument("--root", default=".", help="Repo root directory (default: .)")
    ap.add_argument("--out", default="repo_dump.txt", help="Output file path (default: repo_dump.txt)")
    ap.add_argument("--include-ts", action="store_true", help="Also include .ts/.tsx files")
    ap.add_argument("--include-min", action="store_true", help="Include *.min.js and *.min.css")
    ap.add_argument("--per-file-max-bytes", type=int, default=DEFAULT_PER_FILE_MAX,
                    help="Maximum bytes to read per file (0 = no limit).")
    ap.add_argument("--max-chunk-mb", type=int, default=0,
                    help="Split output into ~N MB chunks (0 = single file).")
    args = ap.parse_args()

    allowed = set(DEFAULT_EXTS)
    if args.include_ts:
        allowed |= TS_EXTS

    skip_suffixes = set() if args.include_min else set(SKIP_SUFFIXES)

    dump_repo(
        root=Path(args.root),
        out_path=Path(args.out),
        allowed_exts=allowed,
        skip_suffixes=skip_suffixes,
        per_file_max=args.per_file_max_bytes,
        max_chunk_mb=args.max_chunk_mb,
    )

if __name__ == "__main__":
    main()
================================================================================
END FILE: dump_repo.py
================================================================================

================================================================================
BEGIN FILE: gui/index.html
================================================================================
<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="status-container">
        <span id="status-text">Jarvis is online. All systems nominal.</span>
        <button id="snapshot-btn">Today's Snapshot</button>
    </div>
    <div id="response-container"></div>
    <div id="input-container">
        <textarea id="prompt-input" rows="1" placeholder="Ask Jarvis..."></textarea>
    </div>
    <script src="script.js"></script>
</body>
</html>
================================================================================
END FILE: gui/index.html
================================================================================

================================================================================
BEGIN FILE: gui/script.js
================================================================================
const input = document.getElementById('prompt-input');
const responseContainer = document.getElementById('response-container');
const statusContainer = document.getElementById('status-container');
const snapshotBtn = document.getElementById('snapshot-btn'); // New button reference

// --- EVENT LISTENERS ---

// Run when the page is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    statusContainer.textContent = "Jarvis is online. All systems nominal.";
});

// Send command on Enter key
input.addEventListener('keydown', function(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        const question = input.value;
        if (question.trim() === '') return;

        displayMessage('You', question);
        input.value = '';
        resizeInput();

        // Show thinking indicator
        const thinkingMessageId = `msg-${Date.now()}`;
        displayMessage('Jarvis', '<span>.</span><span>.</span><span>.</span>', true, thinkingMessageId);

        // Bridge to Python
        window.pywebview.api.process_command(question).then(response => {
            updateMessage(thinkingMessageId, response);
        });
    }
});

// Auto-resize the input text area as the user types
input.addEventListener('input', resizeInput);

function resizeInput() {
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
}

snapshotBtn.addEventListener('click', () => {
    displayMessage('You', '(Requested Daily Snapshot)');
    const thinkingMessageId = `msg-${Date.now()}`;
    displayMessage('Jarvis', '<span>.</span><span>.</span><span>.</span>', true, thinkingMessageId);

    // Call the new, specific Python function
    window.pywebview.api.get_snapshot().then(response => {
        updateMessage(thinkingMessageId, response);
    });
});
// --- UI HELPER FUNCTIONS ---

function displayMessage(sender, message, isThinking = false, messageId = null) {
    const messageBlock = document.createElement('div');
    messageBlock.classList.add('response-block');
    if (messageId) {
        messageBlock.id = messageId;
    }
    
    const senderStrong = document.createElement('strong');
    senderStrong.textContent = `${sender}:`;
    messageBlock.appendChild(senderStrong);

    const contentSpan = document.createElement('span');
    if (isThinking) {
        contentSpan.classList.add('thinking');
    }
    contentSpan.innerHTML = message.replace(/\n/g, '<br>');
    
    messageBlock.appendChild(contentSpan);
    responseContainer.appendChild(messageBlock);
    scrollToBottom();
}

function updateMessage(messageId, newMessage) {
    const messageBlock = document.getElementById(messageId);
    if (messageBlock) {
        // Find the content span and remove the 'thinking' class
        const contentSpan = messageBlock.querySelector('span');
        if (contentSpan) {
            contentSpan.classList.remove('thinking');
            contentSpan.innerHTML = newMessage.replace(/\n/g, '<br>');
        }
    }
    scrollToBottom();
}

function scrollToBottom() {
    responseContainer.scrollTop = responseContainer.scrollHeight;
}
================================================================================
END FILE: gui/script.js
================================================================================

================================================================================
BEGIN FILE: gui/style.css
================================================================================
:root {
    --background-color: #2d2d2d;
    --text-color: #f2f2f7;
    --placeholder-color: #8e8e93;
    --border-color: #3a3a3c;
    --status-color: #a0a0a5;
}
html, body {
    background-color: var(--background-color);
    color: var(--text-color);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    height: 100vh;
    box-sizing: border-box;
    user-select: text !important;
    -webkit-user-select: text !important;
}
#status-container {
    flex-shrink: 0;
    padding: 8px 12px;
    font-size: 13px;
    color: var(--placeholder-color);
    text-align: left;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#snapshot-btn {
    background-color: #444;
    color: var(--text-color);
    border: 1px solid #555;
    border-radius: 5px;
    padding: 4px 10px;
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
}
#snapshot-btn:hover { background-color: #5a5a5a; }
#snapshot-btn:active { background-color: #666; }

#response-container {
    flex-grow: 1;
    overflow-y: auto;
    padding: 12px;
    font-size: 15px;
}
#input-container {
    flex-shrink: 0;
    padding: 0 12px 12px 12px;
}
#prompt-input {
    width: 100%;
    background-color: var(--background-color);
    color: var(--text-color);
    border: none;
    resize: none;
    font-size: 16px;
    padding: 10px 0;
    box-sizing: border-box;
    font-family: inherit;
    max-height: 200px; /* Limit how much it can grow */
}
#prompt-input:focus {
    outline: none;
}
#prompt-input::placeholder {
    color: var(--placeholder-color);
}
.response-block {
    margin-bottom: 15px;
    line-height: 1.5;
    white-space: pre-wrap; /* Helps with formatting */
}
.response-block strong {
    color: var(--status-color);
    display: block; /* Puts sender on its own line */
    margin-bottom: 4px;
}
/* Style for the "thinking..." indicator */
.thinking span {
    animation: blink 1.4s infinite both;
}
.thinking span:nth-child(2) { animation-delay: 0.2s; }
.thinking span:nth-child(3) { animation-delay: 0.4s; }
@keyframes blink {
    0%, 80%, 100% { opacity: 0; }
    40% { opacity: 1; }
}
/* Custom scrollbar for a more modern look */
::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--background-color); }
::-webkit-scrollbar-thumb { background: #555; border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: #777; }
================================================================================
END FILE: gui/style.css
================================================================================

================================================================================
BEGIN FILE: jarvis_app.py
================================================================================
import webview
import sys
import threading
from pynput import keyboard
from jarvis_core import Jarvis

# --- The Same API Class ---
class Api:
    def __init__(self):
        self.jarvis = Jarvis()
        self.window = None

    def process_command(self, command):
        if command:
            return self.jarvis.get_response(command)
        return "Please enter a command."
    
    def get_snapshot(self):
        """A dedicated function called by the Snapshot button."""
        return self.jarvis.run_daily_snapshot()

# --- NEW: Global Hotkey Logic ---
# The key combination to toggle the window
HOTKEY = {keyboard.Key.cmd, keyboard.Key.shift, keyboard.KeyCode.from_char('j')} # For macOS
# For Windows, you would use:
# HOTKEY = {keyboard.Key.ctrl, keyboard.Key.shift, keyboard.KeyCode.from_char('j')}

# The set of keys currently being pressed
current_keys = set()

def toggle_window():
    """Show or hide the Jarvis window."""
    if window.hidden:
        window.show()
    else:
        window.hide()

def on_press(key):
    """Callback function for when a key is pressed."""
    if key in HOTKEY:
        current_keys.add(key)
        if all(k in current_keys for k in HOTKEY):
            # If all hotkeys are pressed, toggle the window
            toggle_window()

def on_release(key):
    """Callback function for when a key is released."""
    try:
        current_keys.remove(key)
    except KeyError:
        pass

# --- Main Execution Block ---
if __name__ == '__main__':
    api = Api()
    
    # Create the window, but start it hidden
    window = webview.create_window(
        'Jarvis',
        'gui/index.html',
        js_api=api,
        width=550,
        height=400,
        resizable=True,
        hidden=True, # Start the window hidden
        on_top=True
    )
    api.window = window
    
    # Start the keyboard listener in a separate thread
    listener = keyboard.Listener(on_press=on_press, on_release=on_release)
    listener.start()
    
    print("ðŸš€ Jarvis is running in the background. Press Command+Shift+J to show/hide.")
    
    # Start the GUI event loop
    webview.start(debug=False)

    # Ensure the listener stops when the app closes
    listener.stop()
================================================================================
END FILE: jarvis_app.py
================================================================================

================================================================================
BEGIN FILE: jarvis_core.py
================================================================================
import os
import re
import datetime
import pickle
import traceback
from openai import AzureOpenAI
from dotenv import load_dotenv
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import notion_client

# Get the absolute path of the directory where this script is located
BASE_DIR = os.path.dirname(os.path.abspath(__file__))

class Jarvis:
    def __init__(self):
        self.client, self.deployment_name = self._initialize_azure_client()
        self.chat_history = []
        self.notion = self._initialize_notion()

    def _initialize_azure_client(self):
        """Initializes and returns the Azure OpenAI client."""
        load_dotenv()
        endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
        api_key = os.getenv("AZURE_OPENAI_KEY")
        deployment_name = os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME")
        if not all([endpoint, api_key, deployment_name]):
            raise ValueError("Azure OpenAI credentials not found in .env file.")
        client = AzureOpenAI(
            azure_endpoint=endpoint,
            api_key=api_key,
            api_version="2024-02-01"
        )
        return client, deployment_name

    def _initialize_notion(self):
        """Initializes and returns the Notion client."""
        notion_api_key = os.getenv("NOTION_API_KEY")
        if not notion_api_key:
            print("Warning: NOTION_API_KEY not found. Notion features will be disabled.")
            return None
        return notion_client.Client(auth=notion_api_key)

    def get_response(self, user_question):
        """The main entry point for processing a user's command and routing to tools."""
        command = user_question.lower()
        context_for_llm = ""
        
        obsidian_keywords = ["obsidian", "vault", "my notes", "remember", "research on"]
        notion_keywords = ["notion", "assignments", "tasks", "dashboard", "email"]
        calendar_keywords = ["calendar", "schedule", "meeting", "event", "priorities", "busy", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday", "today", "tomorrow", "week", "year"]
        snapshot_keywords = ["snapshot", "summary", "daily brief", "what's up"]

        if any(keyword in command for keyword in snapshot_keywords):
            context_for_llm = self._get_daily_snapshot()
        elif any(keyword in command for keyword in obsidian_keywords):
            context_for_llm = self._handle_obsidian_access(command)
        elif any(keyword in command for keyword in notion_keywords):
            context_for_llm = self._handle_notion_access(command)
        elif any(keyword in command for keyword in calendar_keywords):
            context_for_llm = self._handle_calendar_access(command)
        elif command.startswith("read "):
            context_for_llm = self._handle_file_reading(command)

        messages = [{"role": "system", "content": "You are Jarvis, a helpful and concise AI productivity assistant. Analyze the provided context and conversation history to answer the user's question directly and insightfully."}]
        for turn in self.chat_history:
            messages.append({"role": "user" if "You:" in turn else "assistant", "content": turn.split(":", 1)[1].strip()})
        if context_for_llm:
            messages.append({"role": "system", "content": f"Use the following new context to answer the user's question:\n{context_for_llm}"})
        messages.append({"role": "user", "content": user_question})
        
        response = self.client.chat.completions.create(model=self.deployment_name, messages=messages)
        response_text = response.choices[0].message.content

        self.chat_history.extend([f"You: {user_question}", f"Jarvis: {response_text}"])
        if len(self.chat_history) > 8: self.chat_history = self.chat_history[-8:]
            
        return response_text

    def run_daily_snapshot(self):
        """Gathers context and generates a formatted daily snapshot."""
        print("DEBUG: Gathering daily snapshot...")
        # Get today's events from the calendar
        calendar_context = self._handle_calendar_access("today")
        # Get tasks and emails from Notion
        notion_context = self._handle_notion_access("tasks and emails")
        
        snapshot_context = f"{calendar_context}\n\n{notion_context}"

        # Send the combined context to the LLM with a specific prompt
        messages = [{
            "role": "system",
            "content": "You are Jarvis. Analyze the provided context from the user's tools and generate a concise, well-formatted daily snapshot. Use headings for each section (e.g., Calendar, Notion Tasks). If a section has no information, state that clearly."
        }, {
            "role": "user",
            "content": f"Please provide my daily snapshot based on this information:\n{snapshot_context}"
        }]

        response = self.client.chat.completions.create(model=self.deployment_name, messages=messages)
        response_text = response.choices[0].message.content

        # Add this special interaction to chat history
        self.chat_history.extend(["You: (Requested Daily Snapshot)", f"Jarvis: {response_text}"])
        if len(self.chat_history) > 8: self.chat_history = self.chat_history[-8:]

        return response_text


    def _handle_obsidian_access(self, query):
        """Searches or lists notes from the Obsidian vault."""
        try:
            vault_path = os.getenv("OBSIDIAN_VAULT_PATH")
            if not vault_path: return "Context from Obsidian: OBSIDIAN_VAULT_PATH is not set in your .env file."
            vault_path = os.path.expanduser(vault_path.strip("'\""))
            keywords_to_remove = ["obsidian", "vault", "my notes", "remember about", "research on", "anything about", "search for", "in", "my", "about", "what", "are", "is", "a", "an", "the", "notes"]
            clean_query = query.lower()
            for keyword in keywords_to_remove: clean_query = clean_query.replace(keyword, "")
            search_terms = clean_query.strip().split()
            all_notes_content = ""; note_count = 0
            if not search_terms:
                all_notes_content = "Context from Obsidian Vault (File List):\n"
                for root, dirs, files in os.walk(vault_path):
                    for file in files:
                        if file.endswith(".md"): all_notes_content += f"- {file}\n"; note_count += 1
                return all_notes_content if note_count > 0 else "Context from Obsidian: Your vault appears to be empty."
            else:
                all_notes_content = f"Context from Obsidian Notes containing '{' '.join(search_terms)}':\n"
                for root, dirs, files in os.walk(vault_path):
                    for file in files:
                        if file.endswith(".md"):
                            with open(os.path.join(root, file), 'r', encoding='utf-8') as f: content = f.read()
                            if all(term in content.lower() for term in search_terms):
                                all_notes_content += f"\n--- Start of note: {file} ---\n{content[:500]}...\n"; note_count += 1
                return all_notes_content if note_count > 0 else f"Context from Obsidian: I couldn't find any notes containing the terms: {', '.join(search_terms)}."
        except Exception: return f"An unexpected error occurred in Obsidian tool:\n\n{traceback.format_exc()}"

    def _handle_notion_access(self, query):
        """Searches connected Notion databases."""
        if not self.notion: return "Context from Notion: Notion API key is not configured."
        try:
            response = self.notion.search(filter={"value": "database", "property": "object"})
            databases = response.get("results")
            if not databases: return "Context from Notion: No databases are shared with the Jarvis integration."
            all_db_content = "Context from Notion:\n"
            for db in databases:
                db_id = db["id"]; db_title = db.get("title", [{}])[0].get("plain_text", "Untitled Database")
                if "emails" in db_title.lower():
                    all_db_content += f"\n--- Recent Emails from '{db_title}' ---\n"
                    db_response = self.notion.databases.query(database_id=db_id, page_size=5)
                    for page in db_response.get("results", []):
                        title_prop = next((p for p in page["properties"].values() if p["type"] == "title"), None)
                        if title_prop and title_prop["title"]: all_db_content += f"- Subject: {title_prop['title'][0]['plain_text']}\n"
                else:
                    all_db_content += f"\n--- Items from '{db_title}' ---\n"
                    db_response = self.notion.databases.query(database_id=db_id)
                    for page in db_response.get("results", []):
                        title_prop = next((p for p in page["properties"].values() if p["type"] == "title"), None)
                        if title_prop and title_prop["title"]: all_db_content += f"- {title_prop['title'][0]['plain_text']}\n"
            return all_db_content
        except Exception as e: return f"Error accessing Notion: {e}"

    def _handle_calendar_access(self, command):
        """Fetches events from all available Google Calendars."""
        token_path = os.path.join(BASE_DIR, 'token.pickle'); creds_path = os.path.join(BASE_DIR, 'credentials.json')
        try:
            creds = None
            if os.path.exists(token_path):
                with open(token_path, 'rb') as token: creds = pickle.load(token)
            if not creds or not creds.valid:
                if creds and creds.expired and creds.refresh_token: creds.refresh(Request())
                else:
                    SCOPES = ['https://www.googleapis.com/auth/calendar.readonly']; flow = InstalledAppFlow.from_client_secrets_file(creds_path, SCOPES)
                    creds = flow.run_local_server(port=0)
                with open(token_path, 'wb') as token: pickle.dump(creds, token)
            service = build('calendar', 'v3', credentials=creds)
            now = datetime.datetime.now(datetime.UTC); time_min = now
            if "today" in command: time_max = (now + datetime.timedelta(days=1)).replace(hour=0, minute=0, second=0)
            elif "tomorrow" in command: time_min = (now + datetime.timedelta(days=1)).replace(hour=0, minute=0, second=0); time_max = (time_min + datetime.timedelta(days=1))
            elif "year" in command: time_max = now + datetime.timedelta(days=365)
            elif "week" in command: time_max = now + datetime.timedelta(weeks=1)
            else: time_max = now + datetime.timedelta(days=7)
            all_events = []
            calendar_list = service.calendarList().list().execute()
            for calendar in calendar_list.get('items', []):
                events_result = service.events().list(calendarId=calendar['id'], timeMin=time_min.isoformat(), timeMax=time_max.isoformat(), maxResults=25, singleEvents=True, orderBy='startTime').execute()
                all_events.extend(events_result.get('items', []))
            if not all_events: return "Context from calendar: No upcoming events found."
            all_events.sort(key=lambda x: x['start'].get('dateTime', x['start'].get('date')))
            event_list = "Context from calendar:\n"
            for event in all_events:
                start_raw = event['start'].get('dateTime', event['start'].get('date'))
                start = datetime.datetime.fromisoformat(start_raw.replace('Z', '+00:00')).strftime('%a, %b %d @ %I:%M %p')
                event_list += f"- {start}: {event['summary']}\n"
            return event_list
        except Exception as e: return f"Error accessing calendar: {e}"

    def _handle_file_reading(self, command):
        """Reads a single file from the local 'knowledge' directory."""
        match = re.search(r'read\s+([\w\.\-]+)', command)
        if not match: return "Jarvis: I see 'read', but couldn't find a filename."
        filename = match.group(1); file_path = os.path.join(BASE_DIR, "knowledge", filename)
        try:
            with open(file_path, 'r', encoding='utf-8') as f: return f"Context from file '{filename}':\n---\n{f.read()}\n---\n"
        except FileNotFoundError: return f"Jarvis: Error - I could not find '{filename}' in the knowledge folder."
================================================================================
END FILE: jarvis_core.py
================================================================================

================================================================================
BEGIN FILE: testui.py
================================================================================
import webview

if __name__ == '__main__':
    # This creates a simple window with just the text "UI Test"
    webview.create_window('UI Test', html='<h1>Testing the UI...</h1>')
    webview.start(debug=True)
================================================================================
END FILE: testui.py
================================================================================

